// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::depends(BH)]]

#include <RcppArmadillo.h>
#include <boost/random.hpp>
#include <boost/random/uniform_real_distribution.hpp>
#include <boost/random/normal_distribution.hpp>
#include <boost/random/gamma_distribution.hpp>
#include <boost/random/bernoulli_distribution.hpp>
#include <boost/random/beta_distribution.hpp>
//#include <math.h>
//#include <cmath>





using namespace std;
using namespace arma;
using namespace Rcpp;
using namespace boost;
namespace br = boost::random;


// [[Rcpp::export]]
void set_seed(unsigned int seed) {
  Rcpp::Environment base_env("package:base");
  Rcpp::Function set_seed_r = base_env["set.seed"];
  set_seed_r(seed);  
}

namespace normal_func {

    // Returns the erf() of a value (not super precise, but ok)
    double erf(double x)
    {  
     double y = 1.0 / ( 1.0 + 0.3275911 * x);   
     return 1 - (((((
            + 1.061405429  * y
            - 1.453152027) * y
            + 1.421413741) * y
            - 0.284496736) * y 
            + 0.254829592) * y) 
            * exp (-x * x);      
    }

    // Returns the probability of x, given the distribution described by mu and sigma.
    double pdf(double x, double mu, double sigma)
    {
      //Constants
      static const double pi = 3.14159265; 
      return exp( -1 * (x - mu) * (x - mu) / (2 * sigma * sigma)) / (sigma * sqrt(2 * pi));
    }

    // Returns the probability of [-inf,x] of a gaussian distribution
    double cdf(double x, double mu, double sigma)
    {
        return 0.5 * (1 + normal_func::erf((x - mu) / (sigma * sqrt(2.))));
    }

    //generate random number with normal distribution-N(mu,sigma^2)
    double rnorm(double mu, double sigma, boost::mt19937& rng){
            boost::normal_distribution<> nd(mu, sigma);
            boost::variate_generator<boost::mt19937&, 
                           boost::normal_distribution<> > var_nor(rng, nd);
            return var_nor();

    }
}


double runif(double min,double max,boost::mt19937& rng){
            br::uniform_real_distribution< > unif(min, max);
            boost::variate_generator<boost::mt19937&, 
                           br::uniform_real_distribution<> > var_unif( rng,unif);
            return var_unif();
            
}


double rbeta(double e,double f,boost::mt19937& rng){
            br::beta_distribution< > beta_dist(e, f);
            boost::variate_generator<boost::mt19937&, 
                           br::beta_distribution<> > var_beta(rng, beta_dist);
            return var_beta();
            
}







namespace betagamma_func {
  //return the log beta density of shape,scale
  double pdfbeta_log (double x, double s1, double s2){

    return lgamma(s1+s2)-lgamma(s1)-lgamma(s2)+(s1-1)*log(x)+(s2-1)*log(1-x);
  }
  // return the log gamma density of shape-s, rate-r
  double pdfgamma_log (double x, double s, double r){

    return s*log(r)-lgamma(s)+(s-1)*log(x)-r*x;
  }
  // return the log inverse-gamma density of shape-s, rate-r
  double pdfinvgamma_log(double x, double s, double r){
     
     return s*log(r)-lgamma(s)-(s+1)*log(x)-r/x;

  }

  double rgamma( double shape, double rate, boost::mt19937& rng ) {
      double scale=1/rate;
      boost::gamma_distribution<> gd( shape );
      boost::variate_generator<boost::mt19937&,boost::gamma_distribution<> > var_gamma( rng, gd );
      return scale*var_gamma();
    }

  double rinvgamma(double shape, double rate, boost::mt19937& rng){

  	 return 1.0/betagamma_func::rgamma( shape,  rate,  rng);
  }
}



//For variant Markov Random Field prior with two random eta-eta_1,eta_2 for predictor indication variable-Gamma
//incoporating two sources of depedence structures(information) among all the p possible dependent predictors
//where p>>n, n the number of observations 
//apply the similar tenique in Stingo et al 2011 and Moller et al. 2006 
//introduce two additional auxiliary variables-omega_1,omega_2 corresponding to two random eta's-eta_1,eta_2
//Two omega's are generated by perfect simulation using Propp-Wilson exact sampling with reverse order coupled Markov chain 1996
//where the marginal distribution of two omega's are following also MRF distribution with some values of mu and eta's
//Propp-Wilson exact sampling algorithm to generate the auxiliary variable omega for random eta sampling
//input 1: the first dependence adjacent p by p matrix-R1 
//corresponding to first source of dependence information for p predictors
//input 2: the second dependence adjacent p by p matrix-R2 
//corresponding to first source of dependence information for p predictors
//input 3: the parameter-mu in MRF variant prior distribution 
//input 4: the parameter-eta1 in MRF variant prior distribution 
//input 5: the parameter-eta2 in MRF variant prior distribution 
//input 6: T_max the maximum value of T to avoid infinite cycling in reverse coupled Markov chain sampling
IntegerVector proppwilson_omega(IntegerMatrix R1, IntegerMatrix R2, double mu, double eta1, double eta2,unsigned int T_max){
     if (R1.ncol()!=R1.nrow()) stop("input R1 matrix must be square matrix");
     if (R2.ncol()!=R2.nrow()) stop("input R2 matrix must be square matrix");
     if (R1.ncol()!=R2.nrow()) stop("input R1 and R2 matrices must have same dimension");
     unsigned int p=R1.ncol(),T=2;
     int seed2;
     double u;
      //initialize two up and down vectors with values 0 and 1 respectively with the length-p
     int seed=floor(R::runif(0.0,1.0)*1000)+1;
     double ker_ind_up, pi_up_ind,u2;
     //initialize two up and down vectors with values 0 and 1 respectively with the length-p
     IntegerVector x_up(p,0),x_down(p,1);
     NumericVector pi_ker_up_i(p),pi_ker_down_i(p),pi_up(p),pi_down(p);
     unsigned int kk_difsum,kk_tmp,kk_one,kk_zero,k_tmp,len_zero;
     IntegerVector one_tmp(p);
 //    br::uniform_real_distribution< >  uniform_dist01(0.0,1.0);
     while (sum(x_up != x_down)>0) {
       for (unsigned int k=0; k < p; k++){
              x_up[k]=0;
              x_down[k]=1;

        }
      for (int t=-T;t <= -1; t++){ 
        for (unsigned int k=0; k < p; k++){
              pi_ker_up_i[k]=0.0;
              pi_ker_down_i[k]=0.0;

        }
         seed2=-t*seed;
         br::mt19937 generator(seed2);
         //br::uniform_real_distribution< >  uniform_dist01(0.0,1.0);
         //pi_ker_up_i(p,0.0),pi_ker_down_i(p,0.0),pi_up(p,0.0),pi_down(p,0.0);
         for (unsigned int i=0; i < p; i++){           
            for (unsigned int j=0; j < p; j++){
            	 pi_ker_up_i[i] =pi_ker_up_i[i] + eta1*R1(i,j)*x_up[j]+eta2*R2(i,j)*x_up[j];
            	 pi_ker_down_i[i] =pi_ker_down_i[i]+ eta1*R1(i,j)*x_down[j]+eta2*R2(i,j)*x_down[j];
            }
            pi_up[i]=1/(1+1/(exp(mu+pi_ker_up_i[i])));
            pi_down[i]=1/(1+1/(exp(mu+pi_ker_down_i[i]))); 
           // br::mt19937 generator(seed2);
           // br::uniform_real_distribution< >  uniform_dist01(0.0,1.0);
            u=runif(0.0,1.0,generator);         
            if (pi_up[i] > u){
               x_up[i]=1;
            }
            else {
               x_up[i]=0;
            }
            if (pi_down[i] <= u){
               x_down[i]=0;
            }
            else {
               x_down[i]=1;
            }
         }
         
      }
      T=2*T;
      len_zero=0;
      for (unsigned int k=0; k < p; k++ ){                 
                 if (!((pi_down[k]==1) && (pi_up[k]==1))){
                  len_zero++;
                 }
      }
      IntegerVector zero_tmp(len_zero);
      if (T >= T_max) {
          k_tmp=0;
          for (unsigned int k=0; k < p; k++ ){
                 one_tmp[k]=pi_down[k]*pi_up[k];
                 if (!((pi_down[k]==1) && (pi_up[k]==1))){
                  zero_tmp[k_tmp]=1-pi_down[k]-pi_up[k];
                  k_tmp++;
                 }
                 
          }
          kk_one=sum(one_tmp);
          kk_zero=sum(zero_tmp);
          kk_difsum=p-kk_one-kk_zero;
          IntegerVector index_diff(kk_difsum);
          kk_tmp=0;
          for (unsigned int k=0; k < p; k++ ){           
            if (one_tmp[k]==0 && zero_tmp[k]==0){
                 index_diff[kk_tmp]=k;
                 kk_tmp++;
             }                              
          }
          br::mt19937 generator(seed2);
          for (unsigned int l=0; l < 100; l++){
             for (unsigned int m=0; m < kk_difsum; m++){
                 ker_ind_up=0.0;
                 for (unsigned int k=0; k < p; k++){
                   ker_ind_up += eta1*R1(index_diff[m],k)*x_up[k]+eta2*R2(index_diff[m],k)*x_up[k];  
                 }
                 pi_up_ind=1/(1+1/exp(mu+ker_ind_up));
                //br::mt19937 generator(seed2);
              //  br::uniform_real_distribution< >  uniform_dist01(0.0,1.0);
                 u2=runif(0.0,1.0,generator);
                 if (pi_up_ind > u2){
                  x_up[index_diff[m]]=1;
                 }
                 else {
                  x_up[index_diff[m]]=0;

                 }
             }

          }                  
          x_down=x_up;
      }  
               
    }
  return x_up;
  }
/*
//the log density function for the prior of two parameterseta1,eta2 in variant MRF
//where eta1(2)/eta_sd\sim Beta(e,f), where e,f are two hyperparameters
//input 1: the value of the parameter-eta1(2)
//input 2 and 3: e,f are two hyperparameters in prior beta distribution
//input 4: eta_sd: the value of phase transition of eta1(2)
// [[Rcpp::export]]
double pri2eta_beta(double eta,double e, double f, double eta_sd){
	if (eta>eta_sd) stop("the value of eta can't be larger than phase transition eta");
    double logdenbeta=std::log(R::dbeta(eta/eta_sd,e,f,0));
	return logdenbeta;
}

//wrap the function-pri2eta_beta
// pri2eta_beta
double pri2eta_beta(double eta,double e, double f, double eta_sd);
RcppExport SEXP pri2eta_beta(SEXP etaSEXP, SEXP eSEXP, SEXP fSEXP,SEXP eta_sdSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::RNGScope __rngScope;
    Rcpp::traits::input_parameter< double >::type eta(etaSEXP);
    Rcpp::traits::input_parameter< double >::type e(eSEXP);
    Rcpp::traits::input_parameter< double >::type f(fSEXP);
     Rcpp::traits::input_parameter< double >::type eta_sd(eSEXP);
    __result = Rcpp::wrap(pri2eta_beta(eta,e,f,eta_sd));
    return __result;
END_RCPP
}

*/





/*
//update two eta's based on uniform transitional kernel q(eta_new|eta)
//apply auxiliary variable-omega_i for eta_i,i=1,2 in Moller et al. 2006
//input: Gamma: the vector of the elements, which are the index of predictors with indicator variable gamma equal to 1
//input 1: the first dependence adjacent p by p matrix-R1 
//corresponding to first source of dependence information for p predictors
//input 2: the second dependence adjacent p by p matrix-R2 
//corresponding to first source of dependence information for p predictors
//input 3: the parameter-mu in MRF variant prior distribution 
//input 4: the parameter-eta1 in MRF variant prior distribution 
//input 5: the parameter-eta2 in MRF variant prior distribution 
//input 6: T_max the maximum value of T to avoid infinite cycling in reverse coupled Markov chain sampling
input 7: mu_tilde
input 8: eta_tilde
input 9: eta_sd the value of the parameter-eta1(2) at phase transition 
input 10: Gamma: the vector of the elements, which are the index of predictors with indicator variable gamma equal to 1
input 11, 12: e, f the two hyperparameters of prior beta distribution of the two parameters-eta1(2)
input 13: function proppwilson_omega, generate omega auxiliary variable for eta sampling through perfect simulation through
Propp-Wilson exact sampling with reverse order coupled Markov chain 1996
where the marginal distribution of two omega's are following also MRF distribution with some values of mu and eta's
input 14: pri2eta_beta-log density function for prior beta(e,f) distribution of the two parameters-eta1, eta2
*/
// [[Rcpp::export]]
List moller_2eta_unif(IntegerMatrix R1, IntegerMatrix R2, double mu, double eta1, double eta2,unsigned int T_max,
       double mu_tilde,double eta1_tilde,double eta2_tilde,double eta_sd,IntegerVector gamma,double e, double f){
  	   int seed=floor(R::runif(0.0,1.0)*1000)+1;
  	  // br::mt19937 generator(seed);
  	  // br::uniform_real_distribution< >  uniform_dist01(0.0,1.0);
       if (R1.ncol()!=R1.nrow()) stop("input R1 matrix must be square matrix");
       if (R2.ncol()!=R2.nrow()) stop("input R2 matrix must be square matrix");
       if (R1.ncol()!=R2.nrow()) stop("input R1 and R2 matrices must have same dimension");
       if (eta1 > eta_sd) stop("input eta1 value should be smaller than phase transition value");
       if (eta2 > eta_sd) stop("input eta2 value should be smaller than phase transition value");
       unsigned int p=R1.ncol();
       double a1=std::max(0.0,eta1-0.01),b1=std::min(eta_sd,eta1+0.01);
       br::mt19937 generator(seed);
      // br::uniform_real_distribution< >  uniform_dista1b1(a1,b1);
       double eta1_new=runif(a1,b1,generator);
       double a2=std::max(0.0,eta2-0.01),b2=std::min(eta_sd,eta2+0.01);
       //br::uniform_real_distribution< >  uniform_dista2b2(a2,b2);
       double eta2_new=runif(a2,b2,generator);
       double u1,u2;

       IntegerVector omega_eta1=proppwilson_omega(R1,R2,mu,eta1,eta2,T_max);
       IntegerVector omega_eta2=proppwilson_omega(R1,R2,mu,eta1,eta2,T_max);
       IntegerVector omega_eta1new=proppwilson_omega(R1,R2,mu,eta1_new,eta2,T_max);
       IntegerVector omega_eta2new=proppwilson_omega(R1,R2,mu,eta1,eta2_new,T_max);
       //IntegerVector omega_eta1=lomega_eta1[1],omega_eta2=lomega_eta2[1],omega_eta1new=lomega_eta1new[1],omega_eta2new=lomega_eta2new[1];
       int A_eta1new_R1=0,A_eta2new_R1=0,A_eta1_R1=0,A_eta2_R1=0,A_eta1_R2=0,A_eta2_R2=0;
       int A_eta1new_R2=0,A_eta2new_R2=0, B_eta_R1=0,B_eta_R2=0;
       int sum_omega_eta1=0,sum_omega_eta2=0,sum_omega_eta1new=0,sum_omega_eta2new=0;
       for (unsigned int j=0; j < p; j++){
          sum_omega_eta1 += omega_eta1[j];
          sum_omega_eta2 += omega_eta2[j];
          sum_omega_eta1new += omega_eta1new[j];
          sum_omega_eta2new += omega_eta2new[j];
          for (unsigned int k=0; k < p; k++){
            A_eta1new_R1 += omega_eta1new[j]*R1(j,k)*omega_eta1new[k];
            A_eta1new_R2 += omega_eta1new[j]*R2(j,k)*omega_eta1new[k];
            A_eta2new_R1 += omega_eta2new[j]*R1(j,k)*omega_eta2new[k];
            A_eta2new_R2 += omega_eta2new[j]*R2(j,k)*omega_eta2new[k];
            A_eta1_R1 += omega_eta1[j]*R1(j,k)*omega_eta1[k];
            A_eta1_R2 += omega_eta1[j]*R2(j,k)*omega_eta1[k];
            A_eta2_R1 += omega_eta2[j]*R1(j,k)*omega_eta2[k];
            A_eta2_R2 += omega_eta2[j]*R2(j,k)*omega_eta2[k];
            B_eta_R1 += gamma[j]*R1(j,k)*gamma[k];
            B_eta_R2 += gamma[j]*R2(j,k)*gamma[k];

          }
        }
        double priden_eta1new=betagamma_func::pdfbeta_log(eta1_new/eta_sd,e,f);
        double priden_eta1=betagamma_func::pdfbeta_log(eta1/eta_sd,e,f);
        double priden_eta2new=betagamma_func::pdfbeta_log(eta2_new/eta_sd,e,f);
        double priden_eta2=betagamma_func::pdfbeta_log(eta2/eta_sd,e,f);     
        double MHratio_eta1=(eta1_new-eta1)*B_eta_R1+priden_eta1new-priden_eta1+mu_tilde*(sum_omega_eta1new-sum_omega_eta1)
            +eta1_tilde*(A_eta1new_R1-A_eta1_R1)+eta2_tilde*(A_eta1new_R2-A_eta1_R2);
        double MHratio_eta2=(eta2_new-eta2)*B_eta_R2+priden_eta2new-priden_eta2+mu_tilde*(sum_omega_eta2new-sum_omega_eta2)
          +eta1_tilde*(A_eta2new_R1-A_eta2_R1)+eta2_tilde*(A_eta2new_R2-A_eta2_R2);
        double c1=std::max(0.0,eta1_new-0.01),d1=std::min(eta1_new+0.01,eta_sd);
        double c2=std::max(0.0,eta2_new-0.01),d2=std::min(eta2_new+0.01,eta_sd);
        double prop_eta1=log(b1-a1)-log(d1-c1)+mu*(sum_omega_eta1-sum_omega_eta1new)
               +eta1*A_eta1_R1-eta1_new*A_eta1new_R1+eta2*(A_eta1_R2-A_eta1new_R2);
        double prop_eta2=log(b2-a2)-log(d2-c2)+mu*(sum_omega_eta2-sum_omega_eta2new) 
               +eta2*A_eta2_R2-eta2_new*A_eta2new_R2+eta1*(A_eta2_R1-A_eta2new_R1);
        double logMHratio_eta1=MHratio_eta1+prop_eta1;
        double logMHratio_eta2=MHratio_eta2+prop_eta2;
     //   br::mt19937 generator(seed);
       // br::uniform_real_distribution< >  uniform_dist01(0.0,1.0);
        u1=runif(0.0,1.0,generator),u2=runif(0.0,1.0,generator);
        if (log(u1) < logMHratio_eta1){
            eta1=eta1_new;
            omega_eta1=omega_eta1new;
        }
        if (log(u2) < logMHratio_eta2){
            eta2=eta2_new;
            omega_eta2=omega_eta2new;
        }
        return List::create(
               _["eta1"] = eta1, 
               _["omega_eta1"] = omega_eta1,
               _["eta2"] = eta2, 
               _["omega_eta2"] = omega_eta2
                );


     }


    // moller_2eta_unif



/*
//update two eta's based on positive truncated normal transitional kernel q(eta_new|eta)
//between 0 and eta_sd, phase transition value of the two parameters-eta1 and eta2
//apply auxiliary variable-omega_i for eta_i,i=1,2 in Moller et al. 2006
//input: Gamma: the vector of the elements, which are the index of predictors with indicator variable gamma equal to 1
//input 1: the first dependence adjacent p by p matrix-R1 
//corresponding to first source of dependence information for p predictors
//input 2: the second dependence adjacent p by p matrix-R2 
//corresponding to first source of dependence information for p predictors
//input 3: the parameter-mu in MRF variant prior distribution 
//input 4: the parameter-eta1 in MRF variant prior distribution 
//input 5: the parameter-eta2 in MRF variant prior distribution 
//input 6: T_max the maximum value of T to avoid infinite cycling in reverse coupled Markov chain sampling
input 7: mu_tilde
input 8: eta_tilde
input 9: eta_sd the value of the parameter-eta1(2) at phase transition 
input 10: Gamma: the vector of the elements, which are the index of predictors with indicator variable gamma equal to 1
input 11, 12: e, f the two hyperparameters of prior beta distribution of the two parameters-eta1(2)
input 13: function proppwilson_omega, generate omega auxiliary variable for eta sampling through perfect simulation through
Propp-Wilson exact sampling with reverse order coupled Markov chain 1996
where the marginal distribution of two omega's are following also MRF distribution with some values of mu and eta's
input 14: pri2eta_beta-log density function for prior beta(e,f) distribution of the two parameters-eta1, eta2
*/
// [[Rcpp::export]]    
List moller_2eta_trnormal(IntegerMatrix R1, IntegerMatrix R2, double mu, double eta1, double eta2,unsigned int T_max,
         double mu_tilde,double eta1_tilde,double eta2_tilde,double eta_sd,IntegerVector gamma,double e, double f){
    if (R1.ncol()!=R1.nrow()) stop("input R1 matrix must be square matrix");
    if (R2.ncol()!=R2.nrow()) stop("input R2 matrix must be square matrix");
    if (R1.ncol()!=R2.nrow()) stop("input R1 and R2 matrices must have same dimension");
    if (eta1 > eta_sd) stop("input eta1 value should be smaller than phase transition value");
    if (eta2 > eta_sd) stop("input eta2 value should be smaller than phase transition value");
    //generate the new eta1, eta2 based on truncated normal distribution with mean-eta1,eta2, sd-eta_sd
    int seed=floor(R::runif(0.0,1.0)*1000000)+1;
  	br::mt19937 generator(seed);

    unsigned int atap1=0,atap2=0;
    double eta1_new,eta2_new;
  //  boost::normal_distribution<double> normdist_eta1(eta1,eta_sd);
   // boost::normal_distribution<double> normdist_eta2(eta2,eta_sd);
    while (atap1==0){
       eta1_new = normal_func::rnorm(eta1,eta_sd,generator);   
       if (eta1_new > 0 && eta1_new < eta_sd){
        atap1=1;
       }
    }
    while (atap2==0){
       eta2_new = normal_func::rnorm(eta2,eta_sd,generator); ;   
       if (eta2_new > 0 && eta2_new < eta_sd){
        atap2=1;
       }
    }

    unsigned int p=R1.ncol();
    double u1,u2;
    IntegerVector omega_eta1=proppwilson_omega(R1,R2,mu,eta1,eta2,T_max);
    IntegerVector omega_eta2=proppwilson_omega(R1,R2,mu,eta1,eta2,T_max);
    IntegerVector omega_eta1new=proppwilson_omega(R1,R2,mu,eta1_new,eta2,T_max);
    IntegerVector omega_eta2new=proppwilson_omega(R1,R2,mu,eta1,eta2_new,T_max);
    //IntegerVector omega_eta1=lomega_eta1[1],omega_eta2=lomega_eta2[1],omega_eta1new=lomega_eta1new[1],omega_eta2new=lomega_eta2new[1];
    int A_eta1new_R1=0,A_eta2new_R1=0,A_eta1_R1=0,A_eta2_R1=0,A_eta1_R2=0,A_eta2_R2=0;
    int A_eta1new_R2=0,A_eta2new_R2=0, B_eta_R1=0,B_eta_R2=0;
    int sum_omega_eta1=0,sum_omega_eta2=0,sum_omega_eta1new=0,sum_omega_eta2new=0;
    for (unsigned int j=0; j < p; j++){
          sum_omega_eta1 += omega_eta1[j];
          sum_omega_eta2 += omega_eta2[j];
          sum_omega_eta1new += omega_eta1new[j];
          sum_omega_eta2new += omega_eta2new[j];
          for (unsigned int k=0; k < p; k++){
            A_eta1new_R1 += omega_eta1new[j]*R1(j,k)*omega_eta1new[k];
            A_eta1new_R2 += omega_eta1new[j]*R2(j,k)*omega_eta1new[k];
            A_eta2new_R1 += omega_eta2new[j]*R1(j,k)*omega_eta2new[k];
            A_eta2new_R2 += omega_eta2new[j]*R2(j,k)*omega_eta2new[k];
            A_eta1_R1 += omega_eta1[j]*R1(j,k)*omega_eta1[k];
            A_eta1_R2 += omega_eta1[j]*R2(j,k)*omega_eta1[k];
            A_eta2_R1 += omega_eta2[j]*R1(j,k)*omega_eta2[k];
            A_eta2_R2 += omega_eta2[j]*R2(j,k)*omega_eta2[k];
            B_eta_R1 += gamma[j]*R1(j,k)*gamma[k];
            B_eta_R2 += gamma[j]*R2(j,k)*gamma[k];

        }
    }
    //prior density of eta1, eta2,eta1_new,eta2_new
    double priden_eta1new=betagamma_func::pdfbeta_log(eta1_new/eta_sd,e,f);
    double priden_eta1=betagamma_func::pdfbeta_log(eta1/eta_sd,e,f);
    double priden_eta2new=betagamma_func::pdfbeta_log(eta2_new/eta_sd,e,f);
    double priden_eta2=betagamma_func::pdfbeta_log(eta2/eta_sd,e,f);     
    double MHratio_eta1=(eta1_new-eta1)*B_eta_R1+priden_eta1new-priden_eta1+mu_tilde*(sum_omega_eta1new-sum_omega_eta1)
            +eta1_tilde*(A_eta1new_R1-A_eta1_R1)+eta2_tilde*(A_eta1new_R2-A_eta1_R2);
    double MHratio_eta2=(eta2_new-eta2)*B_eta_R2+priden_eta2new-priden_eta2+mu_tilde*(sum_omega_eta2new-sum_omega_eta2)
      +eta1_tilde*(A_eta2new_R1-A_eta2_R1)+eta2_tilde*(A_eta2new_R2-A_eta2_R2);
    //double c1=std::max(0.0,eta1_new-0.01),d1=std::min(eta1_new+0.01,eta_sd);
    //double c2=std::max(0.0,eta2_new-0.01),d2=std::min(eta2_new+0.01,eta_sd);
    double logtrans_eta1new_eta1=log(normal_func::pdf(eta1_new,eta1,eta_sd))-log(normal_func::cdf(eta_sd,eta1,eta_sd)-normal_func::cdf(0,eta1,eta_sd));
    double logtrans_eta1_eta1new=log(normal_func::pdf(eta1,eta1_new,eta_sd))-log(normal_func::cdf(eta_sd,eta1_new,eta_sd)-normal_func::cdf(0,eta1_new,eta_sd));
    double logtrans_eta2new_eta2=log(normal_func::pdf(eta2_new,eta2,eta_sd))-log(normal_func::cdf(eta_sd,eta2,eta_sd)-normal_func::cdf(0,eta2,eta_sd));
    double logtrans_eta2_eta2new=log(normal_func::pdf(eta2,eta2_new,eta_sd))-log(normal_func::cdf(eta_sd,eta2_new,eta_sd)-normal_func::cdf(0,eta2_new,eta_sd));
    
    double prop_eta1=logtrans_eta1_eta1new-logtrans_eta1new_eta1+mu*(sum_omega_eta1-sum_omega_eta1new)
      +eta1*A_eta1_R1-eta1_new*A_eta1new_R1+eta2*(A_eta1_R2-A_eta1new_R2);
    double prop_eta2=logtrans_eta2_eta2new-logtrans_eta2new_eta2+mu*(sum_omega_eta2-sum_omega_eta2new) 
      +eta2*A_eta2_R2-eta2_new*A_eta2new_R2+eta1*(A_eta2_R1-A_eta2new_R1);
    double logMHratio_eta1=MHratio_eta1+prop_eta1;
    double logMHratio_eta2=MHratio_eta2+prop_eta2;
    //br::mt19937 generator(seed);
    //br::uniform_real_distribution< >  uniform_dist01(0.0,1.0);
    u1=runif(0.0,1.0,generator),u2=runif(0.0,1.0,generator);
    if (std::log(u1) < logMHratio_eta1){
        eta1=eta1_new;
        omega_eta1=omega_eta1new;
    }
    if (std::log(u2) < logMHratio_eta2){
        eta2=eta2_new;
        omega_eta2=omega_eta2new;
    }
    return List::create(
    _["eta1"] = eta1, 
    _["omega_eta1"] = omega_eta1,
    _["eta2"] = eta2, 
    _["omega_eta2"] = omega_eta2
    );


  }




/*
detect the phase transition value of eta1, eta2
input 1-min_eta: minimum possible values of eta1, eta2, typical 0
input 2-max_eta:maximum possible value of eta1, eta2, usuallly a large value, case by case, depends on the data 
input 3-mu: another parameter in variant MRF of predictor variable indicator variables-gamma's
input 4-num_rep: number of repeated sampling in gamma's to take average for final output, 10 is sufficient
input 5 function-proppwilson_omega:perfect simulation using Propp-Wilson exact sampling with reverse order coupled Markov chain 1996
finally using plot to check the phase transition point
*/
// [[Rcpp::export]]
IntegerMatrix phase_transit_2eta(IntegerMatrix R1, IntegerMatrix R2, int T_max,double mu,double min_eta,double max_eta,unsigned int num_rep){
   if (min_eta > max_eta) stop("input minimum eta value should be smaller than maximum eta value");
   if (R1.ncol()!=R1.nrow()) stop("input R1 matrix must be square matrix");
   if (R2.ncol()!=R2.nrow()) stop("input R2 matrix must be square matrix");
   if (R1.ncol()!=R2.nrow()) stop("input R1 and R2 matrices must have same dimension");
   unsigned int p=R1.ncol();
   double eta_tmp=min_eta;
   unsigned int len_eta=(max_eta-min_eta)/0.0001+1;
   IntegerMatrix gamma_output(len_eta,num_rep);
   IntegerVector gamma_tmp(p);
   int gamma_tmp2;
   
   for (unsigned int i=0; i < (len_eta); i++){
          for (unsigned int j=0; j < num_rep; j++){
             gamma_tmp=proppwilson_omega(R1,R2,mu,eta_tmp,eta_tmp,T_max);
             gamma_tmp2=0;
             for (unsigned int k=0; k < p; k++){
               gamma_tmp2 += gamma_tmp[k]; 
             }
          gamma_output(i,j)=gamma_tmp2;           
          }     
    eta_tmp +=0.0001;
    }

 return gamma_output;

}
/*
List moller_2eta_unif(IntegerMatrix R1, IntegerMatrix R2, double mu, double eta1, double eta2,int T_max,
double mu_tilde,double eta_tilde,double eta_sd,IntegerVector Gamma,double e, double f,
Function proppwilson_omega,Function pri2eta_beta);
RcppExport SEXP moller_2eta_unif(SEXP R1SEXP, SEXP R2SEXP, SEXP muSEXP, SEXP eta1SEXP, SEXP eta2SEXP,SEXP T_maxSEXP,
SEXP mu_tildeSEXP,SEXP eta_tildeSEXP,SEXP eta_sdSEXP,SEXP GammaSEXP,SEXP eSEXP, SEXP fSEXP,
SEXP proppwilson_omegaSEXP,SEXP pri2eta_betaSEXP)
icensmis_bayesmc_pw_raw(SEXP DmSEXP, SEXP XmatSEXP, SEXP breaksSEXP, SEXP bSEXP, SEXP om1SEXP, SEXP om2SEXP, SEXP niterSEXP, SEXP psampleSEXP, SEXP initsurvSEXP, SEXP nreportSEXP, SEXP fitsurv_pwSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::RNGScope __rngScope;
    Rcpp::traits::input_parameter< IntegerVector >::type R1(R1SEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type R2(R2SEXP);  
    Rcpp::traits::input_parameter< double >::type mu(muSEXP);
    Rcpp::traits::input_parameter< double >::type eta1(eta1SEXP);
    Rcpp::traits::input_parameter< double >::type eta2(eta2SEXP);
    Rcpp::traits::input_parameter< int >::type T_max(T_maxSEXP);
    Rcpp::traits::input_parameter< double >::type mu_tilde(mu_tildeSEXP);
    Rcpp::traits::input_parameter< double >::type eta_tilde(eta_tildeSEXP);
    Rcpp::traits::input_parameter< double >::type eta_sd(eta_sdSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type Gamma(GammaSEXP);
    Rcpp::traits::input_parameter< double >::type e(eSEXP);
    Rcpp::traits::input_parameter< double >::type f(fSEXP);
    Rcpp::traits::input_parameter< Function >::type proppwilson_omega(proppwilson_omegaSEXP);    
   // Rcpp::traits::input_parameter< Function >::type pri2eta_beta(pri2eta_betaSEXP);
    __result = Rcpp::wrap(bayesmc_pw_raw(Dm, Xmat, breaks, b, om1, om2, niter, psample, initsurv, nreport, fitsurv_pw));
    return __result;
END_RCPP
}
*/
